



import os
import numpy as np
import torch
import torch.nn.functional as F
from torch_geometric.data import Data, DataLoader
from torch_geometric.nn import GCNConv

def load_images_to_graph(dataset_path):
    classes = os.listdir(dataset_path)
    num_classes = len(classes)
    images_per_class = []
    edge_index_list = []
    node_features_list = []
    labels_list = []
    for i, c in enumerate(classes):
        class_path = os.path.join(dataset_path, c)
        images = os.listdir(class_path)
        images_per_class.append(len(images))
        for img in images:
            img_path = os.path.join(class_path, img)
            node_features = np.array(Image.open(img_path).convert('L'))  # convert to grayscale
            height, width = node_features.shape
            x, y = np.meshgrid(range(width), range(height))
            x = x.reshape(-1, 1)
            y = y.reshape(-1, 1)
            node_features = np.hstack((x, y, node_features.reshape(-1, 1)))  # (x, y, grayscale) for each pixel
            node_features_list.append(torch.tensor(node_features, dtype=torch.float))
            labels_list.append(i)
            
            # Create edges between neighboring pixels
            edge_index = torch.tensor([], dtype=torch.long)
            for j in range(height):
                for k in range(width):
                    idx = j * width + k
                    if k > 0:
                        edge_index = torch.cat([edge_index, torch.tensor([[idx, idx-1]], dtype=torch.long)], dim=0)
                    if j > 0:
                        edge_index = torch.cat([edge_index, torch.tensor([[idx, idx-width]], dtype=torch.long)], dim=0)
                    if k < width-1:
                        edge_index = torch.cat([edge_index, torch.tensor([[idx, idx+1]], dtype=torch.long)], dim=0)
                    if j < height-1:
                        edge_index = torch.cat([edge_index, torch.tensor([[idx, idx+width]], dtype=torch.long)], dim=0)
            edge_index_list.append(edge_index.t().contiguous())

    # Create PyTorch Geometric Data objects
    data_list = []
    for i in range(len(labels_list)):
        data = Data(x=node_features_list[i], edge_index=edge_index_list[i], y=torch.tensor(labels_list[i], dtype=torch.long))
        data_list.append(data)

    # Create DataLoader
    batch_size = min(images_per_class)  # make sure we have the same number of images per class
    loader = DataLoader(data_list, batch_size=batch_size, shuffle=True)

    # Define GCN model
    class GCN(torch.nn.Module):
        def __init__(self, num_features, hidden_size, num_classes):
            super(GCN, self).__init__()
            self.conv1 = GCNConv(num_features, hidden_size)
            self.conv2 = GCNConv(hidden_size, num_classes)

        def forward(self, x, edge_index):
            x = self.conv1(x, edge_index)
            x = F.relu(x)
            x = self.conv2(x, edge_index)
            return F.log_softmax(x, dim=1)

    # Train GCN model
    model = GCN(num_features=3, hidden_size=16, num_classes=num_classes)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    for epoch in range(200):
        total_loss = 0
    
    
    # Train GCN model
    model = GCN(num_features=3, hidden_size=16, num_classes=num_classes)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    for epoch in range(200):
    total_loss = 0
      for batch in loader:
          optimizer.zero_grad()
          out = model(batch.x, batch.edge_index)
          loss = F.nll_loss(out, batch.y)
          total_loss += loss.item() * batch.num_graphs
          loss.backward()
          optimizer.step()
      if epoch % 10 == 0:
          print('Epoch {0}, Loss {1}'.format(epoch, total_loss / len(data_list)))

